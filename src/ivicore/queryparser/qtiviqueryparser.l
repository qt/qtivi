
%option noyywrap
%option yylineno

/* New lines needed to workaround the sanitize script to not handle this as a autogenerated file */




%top{
/****************************************************************************
**
** Copyright (C) 2016 Pelagicore AG
** Contact: https://www.qt.io/licensing/
**
** This file is part of the QtIvi module of the Qt Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL-QTAS$
** Commercial License Usage
** Licensees holding valid commercial Qt Automotive Suite licenses may use
** this file in accordance with the commercial license agreement provided
** with the Software or, alternatively, in accordance with the terms
** contained in a written agreement between you and The Qt Company.  For
** licensing terms and conditions see https://www.qt.io/terms-conditions.
** For further information use the contact form at https://www.qt.io/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 3 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL3 included in the
** packaging of this file. Please review the following information to
** ensure the GNU Lesser General Public License version 3 requirements
** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 2.0 or (at your option) the GNU General
** Public license version 3 or any later version approved by the KDE Free
** Qt Foundation. The licenses are as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
** included in the packaging of this file. Please review the following
** information to ensure the GNU General Public License requirements will
** be met: https://www.gnu.org/licenses/gpl-2.0.html and
** https://www.gnu.org/licenses/gpl-3.0.html.
**
** $QT_END_LICENSE$
**
** SPDX-License-Identifier: LGPL-3.0
**
****************************************************************************/

// This file was generated by flex - DO NOT EDIT!

//
//  W A R N I N G
//  -------------
//
// This file is not part of the Qt API.  It exists purely as an
// implementation detail. This header file may change from version to
// version without notice, or even be removed.
//
// We mean it.
//

#include <cassert>
#include <QString>
#include <QVariant>
#include <QByteArray>

#if __cplusplus > 199711L
#define register      // Deprecated in C++11.
#endif  // #if __cplusplus > 199711L

#define YY_NO_INPUT
#define YY_DECL int QIviQueryParser::nextToken()
#define YY_USER_INIT initBuffer()
#define YY_USER_ACTION calcCurrentColumn();
extern void readQueryBuffer(char* buffer,unsigned int& numBytesRead,int maxBytesToRead);
int isatty (int ) {
    return 0;
}
#define YY_INPUT(buf,result,max_size) \
    unsigned int res = result; \
    readQueryBuffer(buf, res, max_size); \
    result = res;
}

hex [0-9a-fA-F]
dec [1-9][0-9]*
oct [0-7]
digit [0-9]

fract [+-]?{digit}*\.{digit}+|{digit}+\.
exp [eE][+-]?{digit}+

hexfract {hex}*\.{hex}+|{hex}+\.
binexp [pP][+-]?{digit}+

icst [+-]?({dec}|0{oct}*|0[xX]{hex}+)

%%

"!" { return BANG; }
"!=" { return NE_OP; }
"(" { return LEFT_PAREN; }
")" { return RIGHT_PAREN; }
">" { return GT_OP; }
">=" { return GE_OP; }
"<" { return LT_OP; }
"<=" { return LE_OP; }
"||" { return OR_OP; }
"|" { return OR_OP2; }
"&&" { return AND_OP; }
"&" { return AND_OP2; }
"~=" { return IC_EQ_OP; }
"==" { return EQ_OP; }
"=" { return EQ_OP2; }

"/" { return ASCENDING; }
"\\" { return DESCENDING; }
"[" { return LEFT_BRACKET; }
"]" { return RIGHT_BRACKET; }

[_a-zA-Z][_a-zA-Z0-9]* {
  yylval = QVariant(QLatin1String(yytext));

  return IDENTIFIER;
}

\"(\\.|[^"])*\" {
  QString text = QLatin1String(yytext);
  text.truncate(text.count() - 1);
  yylval = text.mid(1);

  return STRING;
}

\'(\\.|[^'])*\' {
  QString text = QLatin1String(yytext);
  text.truncate(text.count() - 1);
  yylval = text.mid(1);

  return STRING;
}

{icst} {
  yylval = (int) strtol (yytext, 0, 0);
  return INTCONSTANT;
}

{fract}{exp}? {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

{digit}+{exp} {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

0[xX]{hexfract}{binexp} {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

0[xX]{hex}+{binexp} {
  yylval = QByteArray::fromRawData(yytext, yyleng).toDouble();
  return FLOATCONSTANT;
}

[[:space:]]* {
    return SPACE;
}

. {
  return ERROR;
}


%%

